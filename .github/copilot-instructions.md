# Copilot Instructions

- **Project scope**: Tensor decomposition for biomarker data (Python + Julia). Core flows: unconstrained moment tensors ([moments_3rd_order.py](../moments_3rd_order.py), [moments_4th_order.py](../moments_4th_order.py)); constrained ellipsoidal decomposition bridging Python↔Julia ([constrained_moments_decomposition.py](../constrained_moments_decomposition.py), [constrained_cp_decomposition.jl](../constrained_cp_decomposition.jl)). Analysis/reporting lives in [analyze_decomposition.py](../analyze_decomposition.py).
- **Data expectations**: Input from Excel sheet `ATN_sharp` or CSV `NIpanel_msclin_ATNsharp_20241205(1).csv`; first 5 columns are metadata, remaining are 28 biomarkers. Use `load_biomarker_data`/`group_data_by_column` rather than rolling your own parsing. Missing values are column-mean filled; decimal comma handled in [cumulant_tensor_model.py](../cumulant_tensor_model.py#L1-L200).
- **Moment computation**: Moment scripts loop over biomarker permutations to build fully symmetric 3rd/4th-order tensors, then normalize tensors before CP (`tensorly.parafac`, rank default 5, tol 1e-8, n_iter_max 2000). Preserve symmetry by averaging factors across modes before reporting. Keep the `tensor_norm` guard (`<1e-10` → abort) when adding variants.
- **Constrained path**: `constrained_moments_decomposition` computes groupwise covariance (adds 1e-6 I), saves moment/covariance to temp `.npy`, and shells out to Julia. The generated Julia script includes [riemannian_ellipsoid.jl](../riemannian_ellipsoid.jl) and [constrained_cp_decomposition.jl](../constrained_cp_decomposition.jl); each factor column is projected to a covariance-defined ellipsoid (confidence_level default 2.0). Respect this pipeline if extending—keep file I/O formats (`_moment.npy`, `_covariance.npy`, `_factors.npz`) stable.
- **Julia ALS baseline**: Reference manual ALS in [als_cp_decomposition.jl](../als_cp_decomposition.jl) with validation tests in [test_als_cp.jl](../test_als_cp.jl) (run via `julia test_als_cp.jl`). Python mirror in [als_cp_decomposition.py](../als_cp_decomposition.py) matches the same API (khatri-rao, unfold/fold helpers). When changing ALS, update both and keep numerical safeguards (normal equations + pinv fallback; column normalization).
- **Riemannian guides**: [RIEMANNIAN_OPTIMIZATION_GUIDE.md](../RIEMANNIAN_OPTIMIZATION_GUIDE.md) documents projection/retraction and expected precision (~1e-10). Follow its projection-before-optimization rule when adding new constrained flows. Ellipsoid constructors: `AxisAlignedEllipsoid`, `CovarianceEllipsoid`, `Ellipsoid(Q)`.
- **Analysis utilities**: `compare_factors_across_groups`, `analyze_component_structure`, `cluster_biomarkers_by_factors` assume `decomps` entries with `group`, `factors`, `relative_error`. Preserve keys/shape; component 0 drives similarity heatmaps. Visuals depend on matplotlib/seaborn; keep column names aligned with biomarker order.
- **Per-patient tensors**: [symmetric_tensor_per_patient.py](../symmetric_tensor_per_patient.py) builds 28×28×28 tensors (interaction/outer_product/covariance_3d). It normalizes tensors and tries both CP and Tucker, choosing the lower error. If extending, maintain normalization and mode names.
- **Typical workflows**: (1) `python moments_3rd_order.py` or `python moments_4th_order.py` for group-level unconstrained; (2) `python constrained_moments_decomposition.py` for constrained (requires Julia + NPZ/JSON); (3) `python analyze_decomposition.py` to summarize/visualize decomps. Julia demos: `julia riemannian_ellipse.jl`, `julia riemannian_ellipsoid.jl` for geometry sanity checks.
- **Conventions**: Seed with 42 where present; default rank 5; tolerance ~1e-6 to 1e-8. Handle small norms and NaNs defensively. Keep biomarker count at 28 unless you explicitly gate or slice (see patient tensor script warning).
- **Testing**: Use `julia test_als_cp.jl` for ALS regression. No Python test suite; rely on reconstruction error prints. When modifying constrained flow, smoke-test one group with `use_julia=True` and confirm `_factors.npz` emitted.
- **Performance/stability tips**: Large tensor loops are O(n^3/4); prefer vectorization only if symmetry is preserved. Covariance conditioning can be high (1e9–1e10); regularize as in current code instead of changing tolerance silently. Keep verbose flags wired through to surface condition numbers and errors.
- **What to avoid**: Do not change on-disk file names or column order without updating Julia bridge. Avoid removing column normalization/mean fill—it stabilizes high-order moment computation. Preserve symmetry averaging before returning factors and keep rank handling consistent across modes.
